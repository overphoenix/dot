/* Laura Doktorova https://github.com/olado/doT */
!function(e){if("object"==typeof exports&&"undefined"!=typeof module)module.exports=e();else if("function"==typeof define&&define.amd)define([],e);else{("undefined"!=typeof window?window:"undefined"!=typeof global?global:"undefined"!=typeof self?self:this).doT=e()}}(function(){return function(){return function e(n,t,r){function o(s,c){if(!t[s]){if(!n[s]){var u="function"==typeof require&&require;if(!c&&u)return u(s,!0);if(i)return i(s,!0);var f=new Error("Cannot find module '"+s+"'");throw f.code="MODULE_NOT_FOUND",f}var a=t[s]={exports:{}};n[s][0].call(a.exports,function(e){return o(n[s][1][e]||e)},a,a.exports,e,n,t,r)}return t[s].exports}for(var i="function"==typeof require&&require,s=0;s<r.length;s++)o(r[s]);return o}}()({1:[function(e,n,t){"use strict";n.exports={template:f,compile:function(e,n){return f(e,null,n)},setDelimiters:function(e){if(a(e))return void console.log("delimiters did not change");s=l(e),r.delimiters=e}};const r={argName:"it",encoders:{},selfContained:!1,strip:!0,internalPrefix:"_val",encodersPrefix:"_enc",delimiters:{start:"{{",end:"}}"}},o={false:"function",true:"string"},i={evaluate:/\{\{([\s\S]+?(\}?)+)\}\}/g,interpolate:/\{\{=([\s\S]+?)\}\}/g,typeInterpolate:/\{\{%([nsb])=([\s\S]+?)\}\}/g,encode:/\{\{([a-z_$]+[\w$]*)?!([\s\S]+?)\}\}/g,use:/\{\{#([\s\S]+?)\}\}/g,useParams:/(^|[^\w$])def(?:\.|\[[\'\"])([\w$\.]+)(?:[\'\"]\])?\s*\:\s*([\w$]+(?:\.[\w$]+|\[[^\]]+\])*|\"[^\"]+\"|\'[^\']+\'|\{[^\}]+\}|\[[^\]]*\])/g,define:/\{\{##\s*([\w\.$]+)\s*(\:|=)([\s\S]+?)#\}\}/g,defineParams:/^\s*([\w$]+):([\s\S]+)/,conditional:/\{\{\?(\?)?\s*([\s\S]*?)\s*\}\}/g,iterate:/\{\{~\s*(?:\}\}|([\s\S]+?)\s*\:\s*([\w$]+)\s*(?:\:\s*([\w$]+))?\s*\}\})/g};let s={...i};const c={n:"number",s:"string",b:"boolean"};function u(e){return e.replace(/\\('|\\)/g,"$1").replace(/[\r\t\n]/g," ")}function f(e,n,t){const i=n&&n.delimiters,f=i&&!a(i)?l(i):s;let d=0,p=function e(n,t,r,o){return("string"==typeof r?r:r.toString()).replace(t.define,(e,n,r,i)=>(0===n.indexOf("def.")&&(n=n.substring(4)),n in o||(":"===r?(i.replace(t.defineParams,(e,t,r)=>{o[n]={arg:t,text:r}}),n in o||(o[n]=i)):new Function("def",`def['${n}']=${i}`)(o)),"")).replace(t.use,(r,i)=>{i=i.replace(t.useParams,(e,n,t,r)=>{if(o[t]&&o[t].arg&&r){const e=u((t+":"+r).replace(/'|\\/g,"_"));return o.__exp=o.__exp||{},o.__exp[e]=o[t].text.replace(new RegExp(`(^|[^\\w$])${o[t].arg}([^\\w$])`,"g"),`$1${r}$2`),n+`def.__exp['${e}']`}});const s=new Function("def","return "+i)(o);return s?e(n,t,s,o):s})}(n=n?{...r,...n}:r,f,e,t||{});const $={};p=("let out='"+(n.strip?p.trim().replace(/[\t ]+(\r|\n)/g,"\n").replace(/(\r|\n)[\t ]+/g," ").replace(/\r|\n|\t|\/\*[\s\S]*?\*\//g,""):p).replace(/'|\\/g,"\\$&").replace(f.interpolate,(e,n)=>`'+(${u(n)})+'`).replace(f.typeInterpolate,(e,t,r)=>{d++;const o=n.internalPrefix+d,i=`throw new Error("expected ${c[t]}, got "+ (typeof ${o}))`;return`';const ${o}=(${u(r)});if(typeof ${o}!=="${c[t]}") ${i};out+=${o}+'`}).replace(f.encode,(e,t="",r)=>{$[t]=!0,r=u(r);const o=n.selfContained?t:t?"."+t:'[""]';return`'+${n.encodersPrefix}${o}(${r})+'`}).replace(f.conditional,(e,n,t)=>t?(t=u(t),n?`';}else if(${t}){out+='`:`';if(${t}){out+='`):n?"';}else{out+='":"';}out+='").replace(f.iterate,(e,t,r,o)=>{if(!t)return"';} } out+='";d++;const i=o?`let ${o}=-1;`:"",s=o?`${o}++;`:"",c=n.internalPrefix+d;return`';const ${c}=${u(t)};if(${c}){${i}for (const ${r} of ${c}){${s}out+='`}).replace(f.evaluate,(e,n)=>`';${u(n)}out+='`)+"';return out;").replace(/\n/g,"\\n").replace(/\t/g,"\\t").replace(/\r/g,"\\r").replace(/(\s|;|\}|^|\{)out\+='';/g,"$1").replace(/\+''/g,"");const g=Array.isArray(n.argName)?function(e){return e.reduce((e,n,t)=>e+(t?",":"")+n,"{")+"}"}(n.argName):n.argName;return 0===Object.keys($).length?w(()=>new Function(g,p)):(function(e,n){const t=o[e.selfContained];for(const r in n){const n=e.encoders[r];if(!n)throw new Error(`unknown encoder "${r}"`);if(typeof n!==t)throw new Error(`selfContained ${e.selfContained}: encoder type must be "${t}"`)}}(n,$),p=`return function(${g}){${p}};`,w(()=>n.selfContained?new Function(p=function(e,n){let t="";for(const r in n)t+=`const ${e.encodersPrefix}${r}=${e.encoders[r]};`;return t}(n,$)+p)():new Function(n.encodersPrefix,p)(n.encoders)));function w(e){try{return e()}catch(e){throw console.log("Could not create a template function: "+p),e}}}function a({start:e,end:n}){const t=r.delimiters;return t.start===e&&t.end===n}function l({start:e,end:n}){e=p(e),n=p(n);const t={};for(const r in i){const o=i[r].toString().replace(/\\\{\\\{/g,e).replace(/\\\}\\\}/g,n);t[r]=g(o)}return t}const d=/([{}[\]()<>\\\/^$\-.+*?!=|&:])/g;function p(e){return e.replace(d,"\\$1")}const $=/^\/(.*)\/([\w]*)$/;function g(e){const[,n,t]=e.match($);return new RegExp(n,t)}},{}]},{},[1])(1)});
